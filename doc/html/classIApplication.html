<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Polkadot Substrate API for C++: IApplication Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Polkadot Substrate API for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">IApplication Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="iapplication_8h_source.html">iapplication.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IApplication:</div>
<div class="dyncontent">
<div class="center"><img src="classIApplication__inherit__graph.png" border="0" usemap="#IApplication_inherit__map" alt="Inheritance graph"/></div>
<map name="IApplication_inherit__map" id="IApplication_inherit__map">
<area shape="rect" id="node2" href="classCPolkaApi.html" title="CPolkaApi" alt="" coords="9,80,93,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4695f2ee940edb1fff42e4403de6ffaf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a4695f2ee940edb1fff42e4403de6ffaf">connect</a> (string node_url=&quot;&quot;)=0</td></tr>
<tr class="separator:a4695f2ee940edb1fff42e4403de6ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f05ea92d87b60d0f8637ddf3668655b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a5f05ea92d87b60d0f8637ddf3668655b">disconnect</a> ()=0</td></tr>
<tr class="separator:a5f05ea92d87b60d0f8637ddf3668655b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0100dfc23034f7ce58ddc0eed4820d"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structSystemInfo.html">SystemInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#acb0100dfc23034f7ce58ddc0eed4820d">getSystemInfo</a> ()=0</td></tr>
<tr class="separator:acb0100dfc23034f7ce58ddc0eed4820d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874c5af80d7342db07d7581d6f6f80fb"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structBlockHash.html">BlockHash</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a874c5af80d7342db07d7581d6f6f80fb">getBlockHash</a> (unique_ptr&lt; <a class="el" href="structGetBlockHashParams.html">GetBlockHashParams</a> &gt; params)=0</td></tr>
<tr class="separator:a874c5af80d7342db07d7581d6f6f80fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c578b10204f79d0da8cb6479cf0af45"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structMetadata.html">Metadata</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a0c578b10204f79d0da8cb6479cf0af45">getMetadata</a> (unique_ptr&lt; <a class="el" href="structGetMetadataParams.html">GetMetadataParams</a> &gt; params)=0</td></tr>
<tr class="separator:a0c578b10204f79d0da8cb6479cf0af45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf60c651290fb77835f90ec826e2257"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structRuntimeVersion.html">RuntimeVersion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#abdf60c651290fb77835f90ec826e2257">getRuntimeVersion</a> (unique_ptr&lt; <a class="el" href="structGetRuntimeVersionParams.html">GetRuntimeVersionParams</a> &gt; params)=0</td></tr>
<tr class="separator:abdf60c651290fb77835f90ec826e2257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d489ec30c93c7f0a8904241e470a0e8"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structSignedBlock.html">SignedBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a5d489ec30c93c7f0a8904241e470a0e8">getBlock</a> (unique_ptr&lt; <a class="el" href="structGetBlockParams.html">GetBlockParams</a> &gt; params)=0</td></tr>
<tr class="separator:a5d489ec30c93c7f0a8904241e470a0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032059682a287393103d3d655ae7da77"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structBlockHeader.html">BlockHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a032059682a287393103d3d655ae7da77">getBlockHeader</a> (unique_ptr&lt; <a class="el" href="structGetBlockParams.html">GetBlockParams</a> &gt; params)=0</td></tr>
<tr class="separator:a032059682a287393103d3d655ae7da77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0379a5cd2b4c5b2ab68cc6a35e424df8"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structNetworkState.html">NetworkState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a0379a5cd2b4c5b2ab68cc6a35e424df8">getNetworkState</a> ()=0</td></tr>
<tr class="separator:a0379a5cd2b4c5b2ab68cc6a35e424df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0910cbd82cdb26c44ccb21d6c7807ec"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structFinalHead.html">FinalHead</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ac0910cbd82cdb26c44ccb21d6c7807ec">getFinalizedHead</a> ()=0</td></tr>
<tr class="separator:ac0910cbd82cdb26c44ccb21d6c7807ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bd46792a397ccef4152d0e18afb7e6"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structSystemHealth.html">SystemHealth</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a60bd46792a397ccef4152d0e18afb7e6">getSystemHealth</a> ()=0</td></tr>
<tr class="separator:a60bd46792a397ccef4152d0e18afb7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244abecf803f46caea395b7924da23e7"><td class="memItemLeft" align="right" valign="top">virtual unique_ptr&lt; <a class="el" href="structPeersInfo.html">PeersInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a244abecf803f46caea395b7924da23e7">getSystemPeers</a> ()=0</td></tr>
<tr class="separator:a244abecf803f46caea395b7924da23e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dbe556c940f7040eba40beba1b22ae"><td class="memItemLeft" align="right" valign="top">virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ae7dbe556c940f7040eba40beba1b22ae">getAccountNonce</a> (string address)=0</td></tr>
<tr class="separator:ae7dbe556c940f7040eba40beba1b22ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528795695111ed8602a237af9eb4ab93"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a528795695111ed8602a237af9eb4ab93">getKeys</a> (const string &amp;jsonPrm, const string &amp;module, const string &amp;variable)=0</td></tr>
<tr class="separator:a528795695111ed8602a237af9eb4ab93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebe2542237d023c6ccb43c235cf6eed"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a6ebe2542237d023c6ccb43c235cf6eed">getStorage</a> (const string &amp;jsonPrm, const string &amp;module, const string &amp;variable)=0</td></tr>
<tr class="separator:a6ebe2542237d023c6ccb43c235cf6eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3db5a43716118e0265db8c52d9088b9"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ab3db5a43716118e0265db8c52d9088b9">getStorageHash</a> (const string &amp;jsonPrm, const string &amp;module, const string &amp;variable)=0</td></tr>
<tr class="separator:ab3db5a43716118e0265db8c52d9088b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb517cbf28bd8fdea2092b8e56912789"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#aeb517cbf28bd8fdea2092b8e56912789">getStorageSize</a> (const string &amp;jsonPrm, const string &amp;module, const string &amp;variable)=0</td></tr>
<tr class="separator:aeb517cbf28bd8fdea2092b8e56912789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f238f867d7249507716e824755a0b9"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a93f238f867d7249507716e824755a0b9">getChildKeys</a> (const string &amp;childStorageKey, const string &amp;storageKey)=0</td></tr>
<tr class="separator:a93f238f867d7249507716e824755a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111068b55be523ef4b391c7efe77400a"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a111068b55be523ef4b391c7efe77400a">getChildStorage</a> (const string &amp;childStorageKey, const string &amp;storageKey)=0</td></tr>
<tr class="separator:a111068b55be523ef4b391c7efe77400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bf7b09a77a7abcab0017a1ba7a06be"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ab6bf7b09a77a7abcab0017a1ba7a06be">getChildStorageHash</a> (const string &amp;childStorageKey, const string &amp;storageKey)=0</td></tr>
<tr class="separator:ab6bf7b09a77a7abcab0017a1ba7a06be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89211a617600becc8547925057c5103d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a89211a617600becc8547925057c5103d">getChildStorageSize</a> (const string &amp;childStorageKey, const string &amp;storageKey)=0</td></tr>
<tr class="separator:a89211a617600becc8547925057c5103d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee7f495cfdb2e78d59a7b0389ccc257"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a6ee7f495cfdb2e78d59a7b0389ccc257">stateCall</a> (const string &amp;name, const string &amp;data, const string &amp;hash)=0</td></tr>
<tr class="separator:a6ee7f495cfdb2e78d59a7b0389ccc257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db994d5b804b1a9c614968ae31b7343"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a4db994d5b804b1a9c614968ae31b7343">queryStorage</a> (const string &amp;key, const string &amp;startHash, const string &amp;stopHash, <a class="el" href="structStorageItem.html">StorageItem</a> *itemBuf, int itemBufSize)=0</td></tr>
<tr class="separator:a4db994d5b804b1a9c614968ae31b7343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07e2a5b696fa391f6e9c5fb51721dd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ad07e2a5b696fa391f6e9c5fb51721dd4">signAndSendTransfer</a> (string sender, string privateKey, string recipient, uint128 amount, std::function&lt; void(string)&gt; callback)=0</td></tr>
<tr class="separator:ad07e2a5b696fa391f6e9c5fb51721dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a04117025fa7294e540159a102177"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a1a0a04117025fa7294e540159a102177">subscribeBlockNumber</a> (std::function&lt; void(long long)&gt; callback)=0</td></tr>
<tr class="separator:a1a0a04117025fa7294e540159a102177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad743ca6e723a8e98fc6a6fced686341d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ad743ca6e723a8e98fc6a6fced686341d">unsubscribeBlockNumber</a> ()=0</td></tr>
<tr class="separator:ad743ca6e723a8e98fc6a6fced686341d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670a5bca569810701e32167fdb05f858"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a670a5bca569810701e32167fdb05f858">subscribeFinalizedBlock</a> (std::function&lt; void(const <a class="el" href="structBlockHeader.html">BlockHeader</a> &amp;)&gt; callback)=0</td></tr>
<tr class="separator:a670a5bca569810701e32167fdb05f858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978da4e26e10c2c8eba6c4a2bf0d1a16"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a978da4e26e10c2c8eba6c4a2bf0d1a16">unsubscribeFinalizedBlock</a> ()=0</td></tr>
<tr class="separator:a978da4e26e10c2c8eba6c4a2bf0d1a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe114766f62c22f6f7a21eaf3f494283"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#abe114766f62c22f6f7a21eaf3f494283">subscribeRuntimeVersion</a> (std::function&lt; void(const <a class="el" href="structRuntimeVersion.html">RuntimeVersion</a> &amp;)&gt; callback)=0</td></tr>
<tr class="separator:abe114766f62c22f6f7a21eaf3f494283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770f959f96907e1417d6225b01b36103"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a770f959f96907e1417d6225b01b36103">unsubscribeRuntimeVersion</a> ()=0</td></tr>
<tr class="separator:a770f959f96907e1417d6225b01b36103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad12da13245536999799f508d44aab8a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#aad12da13245536999799f508d44aab8a">subscribeStorage</a> (string key, std::function&lt; void(const string &amp;)&gt; callback)=0</td></tr>
<tr class="separator:aad12da13245536999799f508d44aab8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cda3426c157d49772b28f458f9a474"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#af5cda3426c157d49772b28f458f9a474">unsubscribeStorage</a> (string key)=0</td></tr>
<tr class="separator:af5cda3426c157d49772b28f458f9a474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e124c122a6d96ac42ac4cbae1f77bce"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a1e124c122a6d96ac42ac4cbae1f77bce">subscribeBalance</a> (string address, std::function&lt; void(uint128)&gt; callback)=0</td></tr>
<tr class="separator:a1e124c122a6d96ac42ac4cbae1f77bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6422c696fa18a0896456bb8a2b5eae7c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#a6422c696fa18a0896456bb8a2b5eae7c">unsubscribeBalance</a> (string address)=0</td></tr>
<tr class="separator:a6422c696fa18a0896456bb8a2b5eae7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73bb90d3220bcedf18a288fd00654bc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#af73bb90d3220bcedf18a288fd00654bc">subscribeEraAndSession</a> (std::function&lt; void(<a class="el" href="structEra.html">Era</a>, <a class="el" href="structSession.html">Session</a>)&gt; callback)=0</td></tr>
<tr class="separator:af73bb90d3220bcedf18a288fd00654bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6a4f45cecca200c40a3045514cea22"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ada6a4f45cecca200c40a3045514cea22">unsubscribeEraAndSession</a> ()=0</td></tr>
<tr class="separator:ada6a4f45cecca200c40a3045514cea22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad005e633533abd96b0b829c8c6abe16f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#ad005e633533abd96b0b829c8c6abe16f">subscribeAccountNonce</a> (string address, std::function&lt; void(unsigned long)&gt; callback)=0</td></tr>
<tr class="separator:ad005e633533abd96b0b829c8c6abe16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d19365711fdd418038e8463f6a1701"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIApplication.html#af0d19365711fdd418038e8463f6a1701">unsubscribeAccountNonce</a> (string address)=0</td></tr>
<tr class="separator:af0d19365711fdd418038e8463f6a1701"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Communication with Substrate node assumes establishing a secure WebSocket connection using <a class="el" href="classIApplication.html#a4695f2ee940edb1fff42e4403de6ffaf">connect()</a> method, performing all operations as needed using the API calls defined in this interface, and closing connection using <a class="el" href="classIApplication.html#a5f05ea92d87b60d0f8637ddf3668655b">disconnect()</a> method.</p>
<p>Connection can be left open for as long as needed, and it will be maintained by the API. For this reason API runs several maintenance threads and the process that established connection needs to be kept in memory and running.</p>
<p>API calls are thread-safe, yet it is not guaranteed for asynchronous operations that commands will finish (and receive response) in the order they were sent. Also, many API methods use callback mechanism for asynchronous operations. Please do not insert blocking code in the callback handlers because it will block other commands from receiving responses. Responses may be lost and application may enter in a deadlock if handlers block. Also, please do not chain API methods by calling other API methond inside response handlers. </p>

<p>Definition at line <a class="el" href="iapplication_8h_source.html#l00016">16</a> of file <a class="el" href="iapplication_8h_source.html">iapplication.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4695f2ee940edb1fff42e4403de6ffaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::connect </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>node_url</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connects to WebSocket</p>
<p>In order to establish successful TLS connection, a root CA certificate needs to be present in pem file configured in CConstants::certificate_file (currently ca-chain.cert.pem). You can put several certificates in this text file one after the other. Currently Polkadot poc-3 server is using DST_Root_CA_X3 CA and Unfrastructure POC-3 server is using Amazon Root CA 1, so the content of these certificate files is added to ca-chain.cert.pem, but in case if this changes, one can find out the issuer certificate by executing following instructions:</p>
<ol type="1">
<li>Execute <code>curl --insecure -v <a href="https://poc3-rpc.polkadot.io:443">https://poc3-rpc.polkadot.io:443</a></code></li>
<li>Find "issuer" line in the output and download issuer certificate from their website</li>
<li>Execute <code>openssl x509 -in &lt;downloaded_cert_file&gt; -noout -issuer</code></li>
<li><p class="startli">Check folder /usr/share/ca-certificates/mozilla if it has this CA certificate. If it does, copy content to ca-chain.cert.pem, otherwise return to step 2</p>
<p class="startli">Configuration of Node URL</p>
<p class="startli">There are a few options how node URL can be configured. If empty string is provided in parameter and no configuration file is present, the default URL is used. If config file is provided (in the same folder as executable is run from), it overrides default value. If node URL is provided in the parameter, it overrides all other options. Config file has JSON format. Example is provided in config_example.json file in project root on GitHub:</p>
</li>
</ol>
<p><a href="https://github.com/usetech-llc/polkadot_api_cpp">https://github.com/usetech-llc/polkadot_api_cpp</a></p>
<p>Dealing with Substrate Runtime updates</p>
<p>Client application should subscribe to runtimeVersion and, as soon as it receives an update that indicates that runtime version changed, it should disconnect and connect again to recalculate hashers and method and modlue indexes that are required for correct working of other methods.</p>
<p>$param node_url - Node URL to connect to. If set to default value of "", default node URL will be used </p><dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a9f769c53e8b457ae1e19c4782148559b">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a5f05ea92d87b60d0f8637ddf3668655b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IApplication::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from WebSocket </p>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ae50b729de4c0676f4f55f2752002e991">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ae7dbe556c940f7040eba40beba1b22ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned long IApplication::getAccountNonce </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retreives the current nonce for specific address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- the address to get nonce for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address nonce </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ae1faea32c853279c15cb723723dc9c3b">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a5d489ec30c93c7f0a8904241e470a0e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structSignedBlock.html">SignedBlock</a>&gt; IApplication::getBlock </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="structGetBlockParams.html">GetBlockParams</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get header and body of a relay chain block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>with blockHash 64 diget number in hex format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structSignedBlock.html">SignedBlock</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#af7d1cd31d047ee0fc153a49010696e04">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a874c5af80d7342db07d7581d6f6f80fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structBlockHash.html">BlockHash</a>&gt; IApplication::getBlockHash </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="structGetBlockHashParams.html">GetBlockHashParams</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retreives the block hash for specific block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>with blockNumber block number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structBlockHash.html">BlockHash</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a828eab434832ff0a2ee4019aac633972">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a032059682a287393103d3d655ae7da77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structBlockHeader.html">BlockHeader</a>&gt; IApplication::getBlockHeader </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="structGetBlockParams.html">GetBlockParams</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the header for a specific block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>with blockHash 64 diget number in hex format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structBlockHeader.html">BlockHeader</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#afc9715c2e9fefe4962be9f398d11a1f0">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a93f238f867d7249507716e824755a0b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string IApplication::getChildKeys </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>childStorageKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>storageKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls storage_getChildKeys RPC method with given child storage key and storage key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childStorageKey</td><td>- string with 0x prefixed child storage key hex value </td></tr>
    <tr><td class="paramname">storageKey</td><td>- string with 0x prefixed storage key hex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string response from RPC method </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ac50dd82b918e52a61e0a98871cf6ff5b">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a111068b55be523ef4b391c7efe77400a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string IApplication::getChildStorage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>childStorageKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>storageKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls storage_getChildStorage RPC method with given child storage key and storage key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childStorageKey</td><td>- string with 0x prefixed child storage key hex value </td></tr>
    <tr><td class="paramname">storageKey</td><td>- string with 0x prefixed storage key hex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string response from RPC method </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#aca90f90d940fae497dc86b77def3e9de">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ab6bf7b09a77a7abcab0017a1ba7a06be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string IApplication::getChildStorageHash </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>childStorageKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>storageKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls storage_getChildStorageHash RPC method with given child storage key and storage key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childStorageKey</td><td>- string with 0x prefixed child storage key hex value </td></tr>
    <tr><td class="paramname">storageKey</td><td>- string with 0x prefixed storage key hex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string response from RPC method </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a1d2f7fb7d0b43f28523eb23e64f7d2d7">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a89211a617600becc8547925057c5103d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::getChildStorageSize </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>childStorageKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>storageKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls storage_getChildStorageSize RPC method with given child storage key and storage key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childStorageKey</td><td>- string with 0x prefixed child storage key hex value </td></tr>
    <tr><td class="paramname">storageKey</td><td>- string with 0x prefixed storage key hex value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int response from RPC method </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a76534a8467551a104be74934be280b27">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ac0910cbd82cdb26c44ccb21d6c7807ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structFinalHead.html">FinalHead</a>&gt; IApplication::getFinalizedHead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get hash of the last finalized block in the chain</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structFinalHead.html">FinalHead</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a59a00310657c4cf0f09d4692f2bfb9c9">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a528795695111ed8602a237af9eb4ab93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string IApplication::getKeys </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>jsonPrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates storage key for a certain Module and State variable defined by parameter and prefix. Parameter is a JSON string representing a value of certain type, which has two fields: type and value. Type should be one of type strings defined above. Value should correspond to the type. Example:</p>
<p>{"type" : "AccountId", "value" : "5ECcjykmdAQK71qHBCkEWpWkoMJY6NXvpdKy8UeMx16q5gFr"}</p>
<p>Information about Modules and State variables (with parameters and their types) is returned by getMetadata method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonPrm</td><td>- JSON string that contains parameter and its type </td></tr>
    <tr><td class="paramname">module</td><td>- module (as in metadata) </td></tr>
    <tr><td class="paramname">variable</td><td>- state variable (as in metadata for given module) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a5b260a1019ec65084faa54a5766f0971">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a0c578b10204f79d0da8cb6479cf0af45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structMetadata.html">Metadata</a>&gt; IApplication::getMetadata </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="structGetMetadataParams.html">GetMetadataParams</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retreives the runtime metadata for specific block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>with blockHash 64 diget number in hex format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structMetadata.html">Metadata</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ac06a58924477a3e6bd6edd20622eab8f">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a0379a5cd2b4c5b2ab68cc6a35e424df8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structNetworkState.html">NetworkState</a>&gt; IApplication::getNetworkState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns current state of the network</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structNetworkState.html">NetworkState</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a3b38e304102ac980d032f9f1f1955fa9">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="abdf60c651290fb77835f90ec826e2257"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structRuntimeVersion.html">RuntimeVersion</a>&gt; IApplication::getRuntimeVersion </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="structGetRuntimeVersionParams.html">GetRuntimeVersionParams</a> &gt;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retreives the runtime version information for specific block</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>with blockHash 64 diget number in hex format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structRuntimeVersion.html">RuntimeVersion</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a8e53d6d81c312dadbc03c10b122fd9c3">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a6ebe2542237d023c6ccb43c235cf6eed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string IApplication::getStorage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>jsonPrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads storage for a certain Module and State variable defined by parameter and prefix. Parameter is a JSON string representing a value of certain type, which has two fields: type and value. Type should be one of type strings defined above. Value should correspond to the type. Example:</p>
<p>{"type" : "AccountId", "value" : "5ECcjykmdAQK71qHBCkEWpWkoMJY6NXvpdKy8UeMx16q5gFr"}</p>
<p>Information about Modules and State variables (with parameters and their types) is returned by getMetadata method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonPrm</td><td>- JSON string that contains parameter and its type </td></tr>
    <tr><td class="paramname">module</td><td>- module (as in metadata) </td></tr>
    <tr><td class="paramname">variable</td><td>- state variable (as in metadata for given module) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a0d9f1cab6dde3712b404fa46a31d52b0">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ab3db5a43716118e0265db8c52d9088b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string IApplication::getStorageHash </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>jsonPrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns storage hash of given State Variable for a given Module defined by parameter. Parameter is a JSON string representing a value of certain type, which has two fields: type and value. Type should be one of type strings defined above. Value should correspond to the type. Example:</p>
<p>{"type" : "AccountId", "value" : "5ECcjykmdAQK71qHBCkEWpWkoMJY6NXvpdKy8UeMx16q5gFr"}</p>
<p>Information about Modules and State variables (with parameters and their types) is returned by getMetadata method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonPrm</td><td>- JSON string that contains parameter and its type </td></tr>
    <tr><td class="paramname">module</td><td>- module (as in metadata) </td></tr>
    <tr><td class="paramname">variable</td><td>- state variable (as in metadata for given module) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a8a81976762f64712c485819fa2c7920e">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="aeb517cbf28bd8fdea2092b8e56912789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::getStorageSize </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>jsonPrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns storage size for a given State Variable for a given Module defined by parameter. Parameter is a JSON string representing a value of certain type, which has two fields: type and value. Type should be one of type strings defined above. Value should correspond to the type. Example:</p>
<p>{"type" : "AccountId", "value" : "5ECcjykmdAQK71qHBCkEWpWkoMJY6NXvpdKy8UeMx16q5gFr"}</p>
<p>Information about Modules and State variables (with parameters and their types) is returned by getMetadata method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonPrm</td><td>- JSON string that contains parameter and its type </td></tr>
    <tr><td class="paramname">module</td><td>- module (as in metadata) </td></tr>
    <tr><td class="paramname">variable</td><td>- state variable (as in metadata for given module) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#aec33eeebe8772a96123313558c9a2df7">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a60bd46792a397ccef4152d0e18afb7e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structSystemHealth.html">SystemHealth</a>&gt; IApplication::getSystemHealth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return health status of the node</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structSystemHealth.html">SystemHealth</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a15396075e47ad46d7084d0c984841eb1">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="acb0100dfc23034f7ce58ddc0eed4820d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structSystemInfo.html">SystemInfo</a>&gt; IApplication::getSystemInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method calls rpc bellow and puts it together: system_chain system_name system_version system_properties</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structSystemInfo.html">SystemInfo</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ad6a8bb4fb16abb2d9737cb58eda0991d">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a244abecf803f46caea395b7924da23e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unique_ptr&lt;<a class="el" href="structPeersInfo.html">PeersInfo</a>&gt; IApplication::getSystemPeers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the currently connected peers</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structPeersInfo.html">PeersInfo</a> struct with result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#aa5b379d52f022f05731aa22688c5bdb2">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a4db994d5b804b1a9c614968ae31b7343"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::queryStorage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>startHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>stopHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structStorageItem.html">StorageItem</a> *&#160;</td>
          <td class="paramname"><em>itemBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>itemBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls state_queryStorage RPC method to get historical information about storage at a key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- storage key to query </td></tr>
    <tr><td class="paramname">startHash</td><td>- hash of block to start with </td></tr>
    <tr><td class="paramname">stopHsah</td><td>- hash of block to stop at </td></tr>
    <tr><td class="paramname">itemBuf</td><td>- preallocated array of <a class="el" href="structStorageItem.html">StorageItem</a> elements </td></tr>
    <tr><td class="paramname">itemBufSize</td><td>- size of preallocated array of <a class="el" href="structStorageItem.html">StorageItem</a> elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of retrieved items </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a5182c1b2b2413ad4a66e11cfa2b9c2f9">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ad07e2a5b696fa391f6e9c5fb51721dd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IApplication::signAndSendTransfer </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>recipient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint128&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(string)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sign a transfer with provided private key, submit it to blockchain, and wait for completion. Once transaction is accepted, the callback will be called with parameter "ready". Once completed, the callback will be called with completion result string equal to "finalized".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>- address of sender (who signs the transaction) </td></tr>
    <tr><td class="paramname">privateKey</td><td>- 64 byte private key of signer in hex, 2 symbols per byte (e.g. "0102ABCD...") </td></tr>
    <tr><td class="paramname">recipient</td><td>- address that will receive the transfer </td></tr>
    <tr><td class="paramname">amount</td><td>- amount (in femto DOTs) to transfer </td></tr>
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive operation updates </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a6c484c6e69dfea9549640e4f226868fd">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a6ee7f495cfdb2e78d59a7b0389ccc257"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string IApplication::stateCall </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls state_call RPC method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>- name of call </td></tr>
    <tr><td class="paramname">data</td><td>- hex encoded data with 0x prefix </td></tr>
    <tr><td class="paramname">hash</td><td>- hex encoded block hash with 0x prefix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string raw RPC call return </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ae682d626f8d59f211318327cbc767acb">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ad005e633533abd96b0b829c8c6abe16f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::subscribeAccountNonce </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(unsigned long)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to nonce updates for a given address. Only one subscription at a time per address is allowed. If a subscription already exists for the same address, old subscription will be discarded and replaced with the new one. Until unsubscribeNonce method is called with the same address, the API will be receiving updates and forwarding them to subscribed object/function. Only unsubscribeNonce will physically unsubscribe from WebSocket endpoint updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- address to receive nonce updates for </td></tr>
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive nonce updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ac1245151fda85294255234e0a3abf523">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a1e124c122a6d96ac42ac4cbae1f77bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::subscribeBalance </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(uint128)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to most recent balance for a given address. Only one subscription at a time per address is allowed. If a subscription already exists for the same address, old subscription will be discarded and replaced with the new one. Until unsubscribeBalance method is called with the same address, the API will be receiving updates and forwarding them to subscribed object/function. Only unsubscribeBalance will physically unsubscribe from WebSocket endpoint updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- address to receive balance updates for </td></tr>
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive balance updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ace1845dfd005b1d9deecf0f4b4784384">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a1a0a04117025fa7294e540159a102177"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::subscribeBlockNumber </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(long long)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to most recent block number. Only one subscription at a time is allowed. If a subscription already exists, old subscription will be discarded and replaced with the new one. Until unsubscribeBlockNumber method is called, the API will be receiving updates and forwarding them to subscribed object/function. Only unsubscribeBlockNumber will physically unsubscribe from WebSocket endpoint updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#af82b72a2595ad868f73be2609e88d4d3">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="af73bb90d3220bcedf18a288fd00654bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::subscribeEraAndSession </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="structEra.html">Era</a>, <a class="el" href="structSession.html">Session</a>)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to era and session. Only one subscription at a time is allowed. If a subscription already exists, old subscription will be discarded and replaced with the new one. Until subscribeEraAndSession method is called, the API will be receiving updates and forwarding them to subscribed object/function. Only unsubscribeBlockNumber will physically unsubscribe from WebSocket endpoint updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a73f0b668c14afb4f50eef56efb68a998">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a670a5bca569810701e32167fdb05f858"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::subscribeFinalizedBlock </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structBlockHeader.html">BlockHeader</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to most recent finalized block. Only one subscription at a time is allowed. If a subscription already exists, old subscription will be discarded and replaced with the new one. Until unsubscribeFinalizedBlock method is called, the API will be receiving updates and forwarding them to subscribed object/function. Only unsubscribeFinalizedBlock will physically unsubscribe from WebSocket endpoint updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a36ef78b36b2138586242305543accf22">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="abe114766f62c22f6f7a21eaf3f494283"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::subscribeRuntimeVersion </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="structRuntimeVersion.html">RuntimeVersion</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to most recent runtime version. This subscription is necessary for applications that keep connection for a long time. If update about runtime version arrives, it will be necessary to disconnect and reconnect since module and method indexes might have changed.</p>
<p>Only one subscription at a time is allowed. If a subscription already exists, old subscription will be discarded and replaced with the new one. Until unsubscribeRuntimeVersion method is called, the API will be receiving updates and forwarding them to subscribed object/function. Only unsubscribeRuntimeVersion will physically unsubscribe from WebSocket endpoint updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ade0e7d71ed3224adb94976c10b93ca8b">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="aad12da13245536999799f508d44aab8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::subscribeStorage </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to most recent value updates for a given storage key. Only one subscription at a time per address is allowed. If a subscription already exists for the same storage key, old subscription will be discarded and replaced with the new one. Until unsubscribeStorage method is called with the same storage key, the API will be receiving updates and forwarding them to subscribed object/function. Only unsubscribeStorage will physically unsubscribe from WebSocket endpoint updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- storage key to receive updates for (e.g. "0x66F795B8D457430EDDA717C3CBA459B9") </td></tr>
    <tr><td class="paramname">callback</td><td>- functor or lambda expression that will receive balance updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a92fefb0d05fe32526bfb33074e019e26">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="af0d19365711fdd418038e8463f6a1701"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::unsubscribeAccountNonce </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribe from WebSocket endpoint and stop receiving updates for address nonce.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- address to stop receiving nonce updates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a327505a0deff03c01a1023521f4ef18d">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a6422c696fa18a0896456bb8a2b5eae7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::unsubscribeBalance </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribe from WebSocket endpoint and stop receiving updates for address balance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- address to stop receiving balance updates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a2c1fe8a822a04d7a9f0182667e802304">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ad743ca6e723a8e98fc6a6fced686341d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::unsubscribeBlockNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribe from WebSocket endpoint and stop receiving updates with most recent block number.</p>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ab9cc0cd7a71ec2eb65a77fab35e3de96">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="ada6a4f45cecca200c40a3045514cea22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::unsubscribeEraAndSession </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribe from WebSocket endpoint and stop receiving updates with era and session.</p>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a97bb1cf99dcf700547530215a4f4b8b5">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a978da4e26e10c2c8eba6c4a2bf0d1a16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::unsubscribeFinalizedBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribe from WebSocket endpoint and stop receiving updates with most recent finalized block.</p>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a6bf5e5445c1f5f416efb0a8e7557d21b">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="a770f959f96907e1417d6225b01b36103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::unsubscribeRuntimeVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribe from WebSocket endpoint and stop receiving updates with most recent Runtime Version.</p>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#ac770b5a7e97df9ecc7a2698c3a5979ca">CPolkaApi</a>.</p>

</div>
</div>
<a class="anchor" id="af5cda3426c157d49772b28f458f9a474"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IApplication::unsubscribeStorage </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribe from WebSocket endpoint and stop receiving updates for address balance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>- storage key to stop receiving updates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>operation result </dd></dl>

<p>Implemented in <a class="el" href="classCPolkaApi.html#a1bc18feaade5f8b16c0d0d0f87cb4173">CPolkaApi</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/interfaces/<a class="el" href="iapplication_8h_source.html">iapplication.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
